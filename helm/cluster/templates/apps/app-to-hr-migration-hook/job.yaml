{{/*
Pre-upgrade hook to safely migrate default apps from App CRs to HelmReleases.

Uses label selectors to dynamically discover all apps for this cluster,
eliminating hardcoded app lists. Handles apps from both the cluster subchart
and any provider-specific charts (e.g., cluster-aws).

Phase 1 (Non-bundle App CRs + WC Chart CRs):
  - Pause non-bundle App CRs (excludes operators via label selector)
  - Remove finalizers + delete non-bundle App CRs
  - Once App CRs are gone, clean up ALL WC Chart CRs safely
    (no risk of app-operator re-creating them)

Phase 2 (Bundle App CRs via operator cascade):
  - Delete remaining bundle App CRs (excluding operators)
  - app-operator cascade-deletes the MC Chart CRs

Flux then adopts the existing Helm releases via the new HelmRelease CRs.
*/}}
{{- if $.Values.providerIntegration.apps }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "cluster.resource.name" $ }}-migrate-apps-to-helmreleases
  namespace: {{ $.Release.Namespace }}
  labels:
    {{- include "cluster.labels.common.all" $ | nindent 4 }}
  annotations:
    helm.sh/hook: pre-upgrade
    helm.sh/hook-weight: "-10"
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        {{- include "cluster.labels.common.all" $ | nindent 8 }}
    spec:
      serviceAccountName: {{ include "cluster.resource.name" $ }}-migrate-apps
      restartPolicy: Never
      containers:
      - name: kubectl
        image: gsoci.azurecr.io/giantswarm/kubectl:{{ .Values.providerIntegration.kubernetesVersion }}
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          runAsGroup: 1000
          allowPrivilegeEscalation: false
          seccompProfile:
            type: RuntimeDefault
          capabilities:
            drop:
            - ALL
        resources:
          requests:
            cpu: 10m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 512Mi
        command:
        - /bin/sh
        - -c
        - |
          set -eu
          CLUSTER_NAME="{{ include "cluster.resource.name" $ }}"
          NAMESPACE="{{ $.Release.Namespace }}"
          CHART_NAMESPACE="giantswarm"
          BATCH_SIZE=10

          # Fetch WC kubeconfig
          echo "Fetching WC kubeconfig for $CLUSTER_NAME"
          kubectl get secret -n "$NAMESPACE" "${CLUSTER_NAME}-kubeconfig" \
            -o jsonpath='{.data.value}' | base64 -d > /tmp/wc-kubeconfig
          WC="--kubeconfig /tmp/wc-kubeconfig"

          # Label selectors
          # Non-bundle apps: belong to this cluster, version!=0.0.0, excluding operators
          NON_BUNDLE_SELECTOR="giantswarm.io/cluster=$CLUSTER_NAME,app-operator.giantswarm.io/version!=0.0.0,app.kubernetes.io/name notin (chart-operator)"
          # All cluster apps (for Phase 2 discovery)
          CLUSTER_SELECTOR="giantswarm.io/cluster=$CLUSTER_NAME"

          # Helper: check if an app is an operator that must be kept alive.
          is_operator() {
            case "$1" in *-app-operator|*-chart-operator) return 0 ;; esac
            return 1
          }

          # ============================================================
          # Phase 1: Non-bundle App CRs + WC Chart CRs
          # ============================================================

          # 1a. Pause non-bundle App CRs to stop app-operator reconciliation.
          echo "Phase 1a: Pausing non-bundle App CRs"
          kubectl annotate apps.application.giantswarm.io -n "$NAMESPACE" \
            -l "$NON_BUNDLE_SELECTOR" \
            "operatorkit.giantswarm.io/paused=true" --overwrite 2>/dev/null || true

          # 1b. Remove finalizers from non-bundle App CRs (parallel batches).
          echo "Phase 1b: Removing finalizers from non-bundle App CRs"
          NON_BUNDLE_APPS=$(kubectl get apps.application.giantswarm.io -n "$NAMESPACE" \
            -l "$NON_BUNDLE_SELECTOR" \
            -o jsonpath='{.items[*].metadata.name}' 2>/dev/null) || true
          COUNT=0
          for APP in $NON_BUNDLE_APPS; do
            (kubectl patch apps.application.giantswarm.io "$APP" -n "$NAMESPACE" --type=json \
              -p='[{"op": "remove", "path": "/metadata/finalizers"}]' 2>/dev/null || true) &
            COUNT=$((COUNT + 1))
            if [ $((COUNT % BATCH_SIZE)) -eq 0 ]; then wait; fi
          done
          wait

          # 1c. Delete non-bundle App CRs (batch operation).
          echo "Phase 1c: Deleting non-bundle App CRs"
          kubectl delete apps.application.giantswarm.io -n "$NAMESPACE" \
            -l "$NON_BUNDLE_SELECTOR" \
            --ignore-not-found=true --wait=false 2>/dev/null || true

          # 1d. Clean up ALL WC Chart CRs.
          # Now safe: non-bundle App CRs are gone, so app-operator
          # cannot re-create Chart CRs on the WC.
          echo "Phase 1d: Cleaning up ALL WC Chart CRs"

          echo "  Pausing all Chart CRs on WC"
          kubectl $WC annotate chart --all -n "$CHART_NAMESPACE" \
            "operatorkit.giantswarm.io/paused=true" --overwrite 2>/dev/null || true

          echo "  Removing finalizers from all Chart CRs on WC"
          CHARTS=$(kubectl $WC get chart -n "$CHART_NAMESPACE" \
            -o jsonpath='{.items[*].metadata.name}' 2>/dev/null) || true
          COUNT=0
          for CHART in $CHARTS; do
            (kubectl $WC patch chart "$CHART" -n "$CHART_NAMESPACE" --type=json \
              -p='[{"op": "remove", "path": "/metadata/finalizers"}]' 2>/dev/null || true) &
            COUNT=$((COUNT + 1))
            if [ $((COUNT % BATCH_SIZE)) -eq 0 ]; then wait; fi
          done
          wait

          echo "  Deleting all Chart CRs on WC"
          kubectl $WC delete chart --all -n "$CHART_NAMESPACE" \
            --ignore-not-found=true 2>/dev/null || true

          # ============================================================
          # Phase 2: Bundle App CRs via operator cascade
          # ============================================================
          # Delete remaining App CRs (bundles) WITHOUT removing finalizers.
          # app-operator processes the deletion and cascade-deletes the
          # MC Chart CRs. chart-operator then helm-uninstalls the bundles.
          # Excludes app-operator and chart-operator (must stay alive).
          echo "Phase 2: Deleting bundle App CRs (operators will clean up MC Chart CRs)"

          REMAINING_APPS=$(kubectl get apps.application.giantswarm.io -n "$NAMESPACE" \
            -l "$CLUSTER_SELECTOR" \
            -o jsonpath='{.items[*].metadata.name}' 2>/dev/null) || true
          for APP in $REMAINING_APPS; do
            is_operator "$APP" && continue
            kubectl delete apps.application.giantswarm.io "$APP" -n "$NAMESPACE" \
              --ignore-not-found=true --wait=false 2>/dev/null || true
          done

          echo "Migration hook completed successfully"
{{- end }}
